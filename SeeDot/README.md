This project is aimed at generating fixed-point prediction code for the Bonsai and ProtoNN algorithms which are run on resource constrained IoT devices. Currently, the generated code can run on the Arduino devices.

**Workflow**

There are 4 stages in the workflow. The core part of the project is the compiler, which takes as input a training model and generates fixed-point code. Generating efficient fixed-point code depends on how well we can represent real numbers as integers. Hence, finding the right scaling factor used to convert floating-point number to a fixed-point number is critical. To find the most efficient scaling factor, the compiler does a search and chooses the one which best with respect to accuracy. The multiple stages involved in this process is explained below:

1. Prediction is run on the training data to capture some runtime information (profile). The profile contains the range of real numbers computed. This profile is then used by the compiler.
2. The compiler iterates over different scaling factors to generate fixed point code which is run on training data. The prediction accuracy is stored.
3. After the search is completed, the scaling factor which performs best is used to generate the final prediction code targeted at the Arduino device.
4. The code along with the model is then uploaded to an Arduino device. To perform prediction on the device, the test dataset is streamed using serial communication.

**Directory structure**

The project contains 4 sub-projects placed in different folders.

1. **Converter**: This is a python project which takes as input the training model dumps and converts them to C header file. It also generates the input for the compiler.
2. **Compiler**: The compiler takes as input the algorithm, runtime profile, scaling factor and generates fixed point code.
3. **Predictor**: This is a C++ project containing prediction codes for the Bonsai and ProtoNN algorithms. The floating-point code also does profiling during prediction. The bonsai_fixed.cpp and the proton_fixed.cpp are the sample fixed-point code generated by the compiler.
4. **Streamer**: This is a C# project which performs serial communication to stream the dataset to the device.

**Requirements**

1. [**Python 3**](https://www.python.org/)
   - **[Antrl4](http://www.antlr.org/)** (antlr4-python3-runtime): Used by the compiler for lexing and parsing
   - **[Numpy](http://www.numpy.org/)**: Math computation
2. [**Arduino IDE**](https://www.arduino.cc/en/Main/Software): To upload the code to the Arduino device
3. **[msbuild](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild)**: Used to build and execute code in the Predictor project

**Usage**

The compiler can be invoked using the SeeDot.py file. The arguments are supplied as follows:

```
usage: Main.py [-h] -a  --train  --test  --model

optional arguments:
  -h, --help    show this help message and exit
  -a , --algo   Algorithm to run
  --train       Training dataset file
  --test        Testing dataset file
  --model       Directory containing model
```

An example invocation will look something like this:
`python SeeDot.py -a bonsai --train training.txt --test testing.txt --model Bonsai/model`

**Output**

After the execution, the compiler generates two files in the home directory:

1. **model.h** containing the training model along with the Arduino pragmas.
2. **predict.cpp** containing the fixed-point prediction code.

**Prediction on device**

After the compiler generates the output files, it can be used to perform prediction on the device as follows:

1. Upload the **fixed-point.ino** sketch to the device using the Arduino IDE
2. Run **Main.cs** to stream the dataset

